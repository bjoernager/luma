// Copyright 2021-2023 Gabriel Jensen.

use crate::luma::application::Application;
use crate::luma::{LogType, TrapKind};

impl Application {
	pub fn decode(&mut self, opcode: u32) {
		let condition = match opcode & 0b11110000000000000000000000000 {
			0b00000000000000000000000000000 => self.psr & 0b01000000000000000000000000000000 != 0x00,
			0b00010000000000000000000000000 => self.psr & 0b01000000000000000000000000000000 == 0x00,
			0b00100000000000000000000000000 => self.psr & 0b00100000000000000000000000000000 != 0x00,
			0b00110000000000000000000000000 => self.psr & 0b00100000000000000000000000000000 == 0x00,
			0b01000000000000000000000000000 => self.psr & 0b10000000000000000000000000000000 != 0x00,
			0b01010000000000000000000000000 => self.psr & 0b10000000000000000000000000000000 == 0x00,
			0b01100000000000000000000000000 => self.psr & 0b00010000000000000000000000000000 != 0x00,
			0b01110000000000000000000000000 => self.psr & 0b00010000000000000000000000000000 == 0x00,
			0b10000000000000000000000000000 => self.psr & 0b00100000000000000000000000000000 != 0x00 && self.psr & 0b01000000000000000000000000000000 == 0x00,
			0b10010000000000000000000000000 => self.psr & 0b00100000000000000000000000000000 == 0x00 && self.psr & 0b01000000000000000000000000000000 != 0x00,
			0b10100000000000000000000000000 => self.psr & 0b00010000000000000000000000000000 >> 0x1C == self.psr & 0b10000000000000000000000000000000 >> 0x1F,
			0b10110000000000000000000000000 => self.psr & 0b00010000000000000000000000000000 >> 0x1C != self.psr & 0b10000000000000000000000000000000 >> 0x1F,
			0b11000000000000000000000000000 => self.psr & 0b01000000000000000000000000000000 == 0x00 && self.psr & 0b00010000000000000000000000000000 >> 0x1C == self.psr & 0b10000000000000000000000000000000 >> 0x1F,
			0b11010000000000000000000000000 => self.psr & 0b01000000000000000000000000000000 != 0x00 || self.psr & 0b00010000000000000000000000000000 >> 0x1C != self.psr & 0b10000000000000000000000000000000 >> 0x1F,
			0b11100000000000000000000000000 => true,
			_                               => return self.trap(TrapKind::InvalidOpcode(self.registers[0xF] - 0x8, opcode)),
		};
		if !condition { return }

		if opcode & 0b00001110000000000000000000000000 == 0b00001010000000000000000000000000 {
			if opcode & 0b00000001000000000000000000000000 != 0x0 { // Check the L flag.
				self.registers[0xE] = self.registers[0xF] - 0x4;
				
				self.log(LogType::Link(self.registers[0xE]));
			}

			let offset = match opcode & 0b00000000100000000000000000000000 != 0x0 {
				false =>       (opcode          & 0b00000000111111111111111111111111) as i32,
				true  => 0x0 - (!(opcode - 0x1) & 0b00000000111111111111111111111111) as i32, // Inverted (absolute) offset.
			};

			(self.registers[0xF], _) = self.registers[0xF].overflowing_add_signed(offset * 0x4 + 0x8);

			self.log(LogType::Branch(offset, self.registers[0xF] - 0x8));
			return;
		}

		self.trap(TrapKind::InvalidOpcode(self.registers[0xF] - 0x8, opcode));
	}
}
